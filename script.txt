스크립트 작성 규칙:

1. "===="는 슬라이드 구분을 의미합니다. 즉 "===="가 나오면 슬라이드를 넘깁니다.
2. "---"는 진행하면서 걸리는 시간을 메모하는 곳입니다. 진행 시간 뿐만이 아니라 다른 메모할 것들은 "---" 뒤에 작성됩니다.
3. 어조나 말투는 바뀔 수 있습니다. 발표시에, 혹은 연습할 떄 스크립트를 그대로 읽지 않습니다.
4. 스크립트 작성 규칙과 실제 스크립트까지는 3줄 이상의 빈 라인으로 이루어져있습니다.
5. 스크립트는 빈줄을 2개이상 연달아서 사용하지 않습니다.





안녕하세요 이번 주제는 Pythonic Clean Architecture라는 주제로 진행해볼까합니다.
제 소개를 먼저 해볼게요. 저는 라스이고, 현재 스타트업에서 프로그래머로 일하고있습니다.
DDD, CA와 같이 아키텍처와 모델링에 관심이 많고, 함수형 프로그래밍도 좋아해요.
제 트위터나 깃헙에 놀러오셔도 좋을 것 같네요.
그럼 시작해보죠.

====

좋은 아키텍처는 왜 필수적일까요? 한번 상상해볼까요?

여러분들이 개발을 열심히 하고있어요.
그런데 어느순간 이상한 느낌이 들어요. 새로운 기능을 만들거나 조금 수정을 해야하는데 너무 많이 바뀌거나 고려해야해요.
그러다보니 너무 복잡해져서 프로젝트 전체를 이해하기 너무 힘들어지죠.

저는 건축 메타포를 매우 좋아하는데요, 
프로그램을 하나의 건물이라고 생각해볼게요.
건물은 어떤 요소들이 있을까요. 문도 있고, 창문도 있고, 의자가 있을 수도 있죠. 복도가 있을 수도 있고, 화장실도 있겠죠.
우리가 건물을 지을 때는 이런 요소들이 많이 필요하게 되죠.

대부분의 건물은 잘 지어졌지만, 이런 요소들이 배치되어있는 방식에 따라서 건물을 사용하는 느낌이 다를 수 있어요.
창문이 하나도 없다면 너무 답답한 느낌이겠죠. 평범한 크기의 창문이 있다면 많은 경우 만족스러울꺼에요.
그렇다고 모든 곳에 창문이 필수적인 것도 아니죠. 화장실에 평범한 크기의 창문을 두는건 바람직하지 않을 수 있죠.
이런 것들 외에도 복도를 어떻게 위치시키고, 방끼리 어떻게 연결되는지, 가구를 어떻게 배치하는지에 따라서 다른 느낌을 줄 수 있죠.

좋은 아키텍처는 이런 요소들을 적절하게 배치해서 우리가 만들고 싶은 것을 만들어내는거에요. 당연히 고객에게 가치를 제공하는거죠.

건물이 그렇듯, 목적에 따라서 다른 구조를 가져가는게 좋고, 언제나 맞는 정답은 없죠.

이번 발표에서는 이런 건물을 짓는 방법, 아키텍처를 구성하는 방법중 하나인 클린 아키텍처와 DDD에 대하여 이야기를 해볼까 해요.
물론 이 시간에 다 담기 힘든 내용이고, 이게 무조건 좋다는 것은 아니지만 한번쯤 들어보시면 Python 프로그램을 개발하는데 써먹을 수 있는 방식이 하나 추가될꺼에요.

그러면 본격적으로 이야기를 해볼게요.

--- 3min

========

우리가 가장 많이 사용하는 방법은 무엇일까요.

Python에서 서버를 만들 때 유명하고 자주 쓰이는 프레임워크는 Django이죠.
MVC, 혹은 MVT와 같은 방식을 사용하고있죠. 여기서 모델은 무엇일까요? 바로 DB에요.
아마 많은 분들은 이 방식에 익숙해져있을 것 같아요. 어떤 프로그램을 만들려고 한다면 DB부터 생각하는 경우도 많을 것 같네요.

하지만 이번 시간에서 Model은 DB라는 생각을 잊어버리고 들어주셨으면 좋겠어요.

--- 1min(4min)

=====

오래기다리셨습니다. 클린 아키텍처에 대한 이야기를 본격적으로 해볼게요.

=====

클린 아키텍처는 대강 이런 그림으로 설명할 수 있어요.
도메인 모델들이 한가운데 있죠. 그리고 도메인 모델을 사용해서 어플리케이션 로직을 처리하는 use case들이 있어요.
그리고 use case를 사용하여 외부 API와 이어주는 presentation layer도 있네요.
여기서 DB는 아주 바깥 부분에 위치하고 있습니다. 그리고 model이나 use case는 DB를 몰라요.

이것만 들어서는 어떻게 하느지 전혀 모르실 것 같아서 예시를 보면서 진행해볼게요.

====

처음에는 우리가 만들고 싶은 것들을 정해요.
저는 이번에 칸반보드를 만들어볼게요.

칸반 보드는 꽤 유명해서 많은 분들이 아실 것 같네요.

개인적으로 usecase를 먼저 구현하면서 동작들을 나열하는것을 선호합니다.

우리의 프로그램들은 어떤 유즈케이스를 갖고있을까요?
"칸반 보드 생성", "백로그에 카드 추가", "백로그에서 Todo로 카드 이동", "Done에 있는 카드 삭제"
이런 동작들이 있겠죠. 간단한 프로그램을 만들어도 아주 많은 동작들이 생기게되죠.
행동을 단순한 "CRUD"로 생각하지 마시고, 실제 유저의 입장에서 행동을 바라보시면 좋을 것 같아요.

유즈케이스를 잘 작성하는 것도 꽤나 어려운 일인데요, 이러한 책을 참고하시면 더 좋을 것 같습니다.

알리스터 코오번이라는 분이 쓰신 책인데, 내용이 꽤나 좋아요.

====

이렇게 생각해낸 우리 프로그램의 행동들을 코드로 표현해줍시다.
이게 바로 클린 아키텍처의 중심이 되는 Use Case입니다.
Use Case를 보면 이 시스템은 유저와 어떻게 상호작용하는지 알 수 있습니다. 즉, 어떤 프로그램인지 알 수 있죠.
이렇게 보시다시피 간단하게 Class와 메서드로 만들 수 있습니다. Python에서 이제 Type은 필수죠!

하나의 유즈케이스가 너무 많거나 복잡해진다면 각 유즈케이스별로 하나의 클래스를 만들 수도 있습니다.

그리고 유즈케이스를 적절하게 클래스별로 쪼갤 수도 있죠!

앞으로도 이야기하면서 이렇게 여러가지 방법에 대하여 소개하려고 해요.
제일 처음에 이야기했듯, 아키텍처는 상황에 맞게 구성해야하니까요.

====

유즈케이스가 나열되었고 표현되었으면 실제 내부를 채워넣을 시간입니다.
내부 동작을 구현하기 위해서는 도메인 모델을 만들어야해요.

우리가 이 프로그램에서 다룰 개념들이 바로 이 도메인 모델이죠. 도메인 객체라고도 부릅니다.

지금 상황에서는 보드, 카드, 백로그, Todo등이 도메인 모델에 포함됩니다.

당연하게도 객체로 표현할 수 있죠.

도메인 모델중 하나인 Entity를 먼저 보겠습니다.

====

도메인 모델중 한 종류인 entity는 식별성을 가지는 객체에요.

즉, ID가 존재하고 ID가 같으면 같은 객체로 보는 것이죠.

사람을 예로 들면, 이름, 나이, 생일이 모두 같아도 같은 사람은 아니겠죠. 이런 것들이 엔티티에 해당하는 것들이에요.

보시다시비 간단한 Class로 표현이 가능하죠.

우리가 Class, 즉 객체지향 프로그래밍을 처음 배웠을 때를 떠올리며 순수한 객체로 만들면 끝이에요.

여기에서는 Django나 DB, API 형태를 생각할 필요는 없어요.

이걸 어떻게 json으로 나타내지? 와 같은 것들은 나중에 고민해봐요.

====

모든 개념이 ID가 존재하는걸까요? ID가 없어도 괜찮은 개념들이 있을 수도 있어요. 색을 표현하는 객체가 대표적이죠.

이렇듯 값을 표현하는 방법이 바로 도메인 모델중 한 종류인 Value object에요.

간단하게 Dataclass로도 구현이 가능해요. 값이니까요!!

그리고 순수한 객체여야하죠. 위에서 이야기했듯, DB나 json은 무시하도록해요.

Value object의 경우에는 불변성을 가진 객체로 만들어주면 더 좋을 것 같아요.

상태를 가진 entity라기보다는 값이니까요.

그리고 dataclass뿐만 아니라 비슷한 것을 하는 다른 라이브러리를 쓸 수도 있어요.

저는 개인적으로 외부 라이브러리를 쓰는걸 안좋아해서 Dataclass를 바로 쓰는 편이에요.

도메인 객체에 외부 라이브러리를 쓰는게 좋은지 안좋은지에 대한 의견이 갈리는데요, 지금 있는 회사에서는 쓰는 경우도 있는 것 같아요.

늘 그렇듯 선택사항인거죠.

-- 여기까지 10min

====

우리가 이렇게 순수한 객체들로 필요한 개념들을 만들게 되었는데, 이걸 저장할 필요는 없을까요?

프로그램이 종료되면 우리가 만들었던 객체들은 어디엔가 저장이 되어야할꺼에요.

그런 역할을 하는 것들이 바로 Repository이죠.

이렇게 인터페이스로 만들 수 있어요.

Repository는 실제로 어떤 DB를 쓸건지 모르는 상태에요. 그저 우리가 만든 개념들을 저장하고 가져올 수 있는 메서드들이 존재하죠.

우리는 이 Repository가 객체를 어떻게 저장하는지 신경쓰지 않을꺼에요. 다른 CRUD만 하는 서버에 요청을 보낼 수도 있고, 혹은 직접 DB에 저장할 수도 있죠.

아니면 메모리에만 저장할 수도 있어요. 그러면 프로그램이 종료되면 날아가겠지만, 한 프로그램 안에서는 데이터가 남아있을꺼에요.

====

여기서 의문을 가지실 분이 계실 것 같아요. "Python은 duck type이라서 인터페이스 필요없는거 아니에요?"

맞습니다. 사실 인터페이스를 쓰지 않고도 우리가 앞으로 하려는 것을 할 수 있어요. 이런 인터페이스를 만드는 것은 타입이 있는 정적 타입 언어에서 많이 하는 것들이거든요.
저는 개인적으로 인터페이스를 만들어두는게 개발하기 쉬워서 이렇게 하는 편이에요. 암시적인 제약을 명시적으로 만들어주거든요.

하지만 이는 개인 취향이기에 Python의 자유로움과 생산성을 해친다고 생각하신다면 사용하시지 않아도 좋을 것 같네요.

====

다시 돌아와서, 실제 우리가 사용할 Repository는 아까 만들었던 Repositroy 인터페이스를 구현해야해요.

저 인터페이스를 맞추기 위해서 Django, 아니면 Dynamo DB, Redis, 혹은 다른 서버등등 여러가지 방법을 쓸 수 있죠.

객체를 어떻게 저장하고 가져오는지 이곳만 보면 알 수 있죠. 관심사를 집중시키는거에요.

====

Repository를 실제로 사용하는 쪽에서는 어떤 구현체를 쓰는지 모르는 상태로 쉽게 사용할 수 있죠.

테스트때는 다른 객체를 사용할 수도 있을꺼구요!! 결국에는 Repository가 갖고있는 책임을 잘 완수하기만 한다면 큰 문제가 없는 것 같아요.

====

네트워크 호출도 비슷하게 만들 수 있어요.

어떤 행동을 하는 일반적인 인터페이스를 만든다음, 그걸 구현하는 구현체를 만드는거죠.

그리고 바깥에서는 인터페이스만 사용하면 내부 동작이 어떤지 신경쓰지 않고 개발할 수 있어요.
내부 동작을 바꾸어서 끼우기도 더 쉬워지죠.

====

혹시나 구현체가 너무나 많아진다면 이렇게 의존성을 모아서 관리하는 객체를 만들수도 있어요.

지금 보시는 코드는 실제 회사에 있는 코드인데, 디펜던시 컨테이너에 셋팅만 해주면 알아서 필요한 구현체를 선택해주어서 사용할 수 있어요.

여기서 신경쓰면 좋은 문제는 이렇게 만들어진 객체를 어떻게 관리할지 입니다.

singleton처럼 모든 경우에 하나의 객체에 접근하게 할 것인지, 아니면 필요할때마다 생성해서 사용할 것인지 생각할 수도 있죠.

어떤 경우에 사용하느냐에 따라서 다른 것 같아요. 여러 객체가 동시에 한 객체에 접근해도 괜찮도록 만들 수 있다면 제일 좋겠지만요.

이런 동시성 문제는 asyncio를 적용하면 또 문제가 됩니다.

====

그럼 이제 동시성 문제를 같이 다뤄볼까요?

최근 파이썬이 집중했던 부분을 뽑으라고 한다면 asyncio가 떠오르시는 분들이 많을 것 같습니다. 새로운 기능들도 꽤 나왔죠.
라이브러리도 지원되기 시작하고 점점 많이 사용되기 시작하는 것 같아요. 성능 개선도 분명 있구요.

점점 asyncio를 많이 사용하게 되고 필요성이 들어나면서 우리의 아키텍처에도 asyncio를 쓰고싶으신 분들이 많을 것 같아요.
지금 바로 그 부분을 살펴보죠.

====

asyncio를 사용하게 된다면 프로젝트 전반에 걸친 수정이 필요할 수도 있고, 바뀌는 부분을 특정 부분으로 제한시킬 수도 있습니다.

저는 개인적으로 프로젝트 초반부터 asyncio를 적용하게 된다면 use case부터 async하게 만들어요. 왜냐면 우리는 아직 라이브러리에 대한 내용을 모르기때문이죠.
sanic을 쓸지 fastapi를 쓸지도 모르는 상황이니까요.

그래서 use case를 async하게 구현하고, 프로젝트를 개발해나가는 편이에요.

이런 timeout같은 로직들도 use case에 넣을 수도 있고, 아니면 repository 내부에 넣을 수도 있어요. 아니면 use case를 사용하는 쪽에서 넣을 수도 있죠.

저는 이번에 use case에 넣어보았습니다. 상황에 맞게 적절하게 넣어주시면 될 것 같아요.

Repository에 넣는다면 Repository를 쓰는 모든 곳에 적용이 되겠죠. UseCase에 넣는다면 모든곳은 아니겠지만, use case를 쓰는 경우에는 적용되겠죠.
바깥에 이런 로직을 넣는것도 방법이겠지만, 하나의 usecase에서 기다려야하는 여러가지 메서드가 있을 때 각각의 timeout을 제어하지 못할꺼에요.

====

Repositroy로 넘어가볼까요?

위에서 보셨다시피 Repository의 메서드도 바뀌어야합니다. Repository는 DB 혹은 네트워크 통신등 대기하는 시간이 많은 경우가 잦습니다.

그래서 가장 먼저 적용하게 되는 부분이죠. Repository의 인터페이스를 바꾸어주고, 실제 구현도 조금 바꿔주어야겠죠.

엄청나게 어렵지는 않죠?

사실 asyncio를 사용하면서 여러가지 동시성 문제들과 back pressure, timeout등의 문제를 어떻게 풀면 좋을지 깊게 다루지는 않았는데요.
이렇듯 동시성 프로그래밍을 하기 시작하면 여러가지 신경써야 할 것들이 늘어납니다. 그만큼 프로그램이 복잡해지겠죠.
하지만 동시성이 가져다주는 이점은 엄청날 수 있습니다.

늘 그렇듯, 적재적소에 사용해야하는거죠.

====

이렇게 use case를 잘 만들어 두었으면 개발이 끝난걸까요?
아니겠죠. 외부 사용자를 위한 인터페이스를 제공해야해요. 그 방법은 GUI가 될 수도 있고, GRPC가 될 수도 있죠.
아니면 흔하게 사용하는 HTTP API일 수도 있어요.

대부분의 경우 개발하게 되면 API를 먼저 코딩하게 되는 경우가 잦은데, 지금까지는 API를 생각하지 않고 개발을 진행해온거죠.
우리가 중요하게 생각하는 동작, 즉 use case는 모두 만들어져있기때문에 그 use case를 외부 인터페이스랑 연결시켜주기만 하면 되는거죠!
실제로 어떻게 하는지 살펴볼게요.

====

최근에 인기있는 fast api를 예시로 들어볼게요.

use case를 만들고, 어떤 객체를 사용할지 선택해요. 
의존성을 주입받는거죠.

그리고 API를 정의해요. API를 정의하면서 컨트롤러에서 use case를 통해서 실제 동작을 진행하게 되죠.
도메인 객체를 바로 json으로 만들기는 힘들어서 따로 DTO를 두어 json으로 만드는 방법을 제공해요.

만약 response가 바뀌었다고 하면 이쪽에서만 바뀌면 되는거에요. 중요한 로직은 use case로 감싸져있기때문에 영향을 주는 경우가 적어져요.

====

어느정도 기능이 만들어졌으니 프로젝트 전체를 잠깐 살펴볼까요?

지금 프로젝트는 이렇게 구성되어있어요. 물론 다르게 구성할 수도 있고, 제가 좋아하는 방식을 선택했을 뿐이에요.

adapter라는 패키지에는 실제 구현들이 들어있어요. 지금은 djnago를 repository 구현체가 보이네요.

이 adapter라는 이름은 port & adapter, 혹은 헥사고날 아키텍처라는 아키텍처 패턴에서 가져왔어요. 클린 아키텍처의 조상이라고 할 수도 있는 아키텍처이죠.

그리고 application에는 use case들이 있어요. application specific domain logic이 들어있죠. 이 레이어는 서비스 레이어라고 불리기도 해요.

controller에는 api들이 있어요. presentation이라고 불러도 괜찮아요. fast api를 쓴 api의 라우터 혹은 컨트롤러들이 존재해요.

domain에는 우리의 중요한 개념들인 도메인 객체들이 존재해요. 어떤 분들은 model이라는 패키지 이름을 좋아하시지만, 저는 django의 model과 오해할 수도 있을 것 같아서 domain이라고 하는 편이에요.

====

처음에 보았던 clean architecture의 그림과 비교해본다면 얼추 비슷하게 구성되어 있죠. UI, controller가 바깥에 있으면서 domian / use case에 의존하고 있어요.

domain model 혹은 use case는 DB, API, UI를 모르는 상태이죠. 혹시 domain model이나 use case에 서비스 api에 대한 내용이 있거나, DB에 대한 내용이 있다면 clean architecture를 잘 따른다고 할 수 없을꺼에요.

설계 원칙인 SRP, DIP등을 어기는 것이기도 하구요.

====

지금까지 대표적인 패턴에 대하여 살펴보았다면 이제부터 조금 더 특수한 상황에서 쓰일 수 있는 방법들을 소개해볼까합니다.

지금까지 소개한 것들을 이용해서도 프로그램을 만들 수도 있지만, 몇가지 상황에서는 부족한 경우도 있습니다.

엄청나게 자세하게 설명하지는 않겠지만, 키워드를 알고계시면 도움이 될꺼에요.

====

지금 구조에서는 use case의 메서드 시그니처로 domain model이 바로 사용되고 있어요. 하지만 이렇게 되면 presentation에서도 domain model을 참조하게 되요.

이렇게 되다보면 domain model의 내부 상태를 과도하게 노출하는 일이 생길 수도 있고, domain model이 바뀌면 너무 많은 부분이 변경되어야 할 수도 있어요.

그걸 제한하기 위해서 local dto라는 방식을 사용할 수도 있어요. 그렇게 되면 application layer밖으로 도메인 모델이 노출되지 않아요.

====

기존에 소개하지 않았던 방법으로는 domain event가 있어요.

모델링 할 수 있는 방법중에 하나이고, 꽤나 많은 변경이 필요하게 되어요.

여기서는 잠깐만 이야기해볼게요.

====

어떤 사건이 벌어졌을 때 event를 발생하고 그걸 로컬 메세지 버스에 넣고 그 메세지 버스의 메세지를 꺼내서 실행시킬 수 있어요.

이것도 유즈케이스와 같이 모델링이 될 수 있죠.

그리고 만약 어떤 이벤트들은 외부 서비스로 나가야한다면 외부 메세지 큐에 메세지를 발행할 수도 있어요.

만약 이렇게 이벤트라는 개념을 사용해서 시스템을 모델링 하고싶다면 여러가지 좋은 점들도 있지만, 프로젝트가 더 복잡해지는 경우도 있어요.

회사에서는 많은 마이크로서비스들이 이벤트를 적극적으로 사용하고 있고, 메세지 버스를 많이 쓰고 있어요.

개인적으로는 만족스럽게 사용되는 것 같아요.

이번에는 이정도로만 간단하게 설명하고 넘어가볼게요.

====

프로젝트가 특정 데이터를 가져오는 api가 성능이 필요한 경우 CQRS를 적용해 볼 수도 있어요.

Greg Young이 만든 이 아키텍처 패턴은, API를 view와 command로 나누어요. 그리고 view를 담당하는 아키텍처와 command를 담당하는 아키텍처를 각각 구성하죠.

그래서 우리가 지금까지 했던 clean architecture, DDD, repositroy들은 command쪽에 적용하고 view은 raw 쿼리를 작성하는 식이에요.

이렇게 되면 DB를 더 효율적으로 사용할 수 있죠. 그리고 command는 데이터를 바꾸기만 하는 것이기에 사용하는 입장에서 끝날때까지 기다릴 필요도 없어요.

성능 최적화를 해야한다거나 view 로직이 복잡하면 적용해보면 좋겠지만, 프로젝트의 복잡성을 증가시키는 단점도 있답니다.

만약 Python에서 함수형 프로그래밍을 하고 싶고, roll back이 필요한 경우가 잦다고 한다면 command쪽 아키텍처에만 event sourcing을 적용할 수도 있습니다.

저는 CQRS는 조심스럽게 적용시키는 편이에요.

====

unit of work는 DB에 너무 잦은 수정이 생기는 것을 방지하기 위해서 생긴 방식이에요.

DB의 수정을 작업 단위로 몰아서 처리하면서 어느정도 성능적인 개선을 기대할 수도 있죠.

====

asyncio를 같이 적용할 수도 있어요!

지금까지 꽤나 많은 패턴들을 가볍게 살펴보기만 했는데, 실제로는 더 많은 내용이 숨어있답니다.

====

더 궁금하시다면 이런 책들을 참고하시면 좋을 것 같아요.

====

마틴파울러가 쓴 "Patterns of Enterprise Application Architecture"는 아주 많은 패턴들이 담겨있어요.

====

eric evans가 쓴 DDD는 도메인 모델을 잘 정의하고 설계하는 방식에 대한 내용을 담고 있어요.

=== 

반 버논이 쓴 IDDD는 실제 구현 사례들과 DDD의 비교적 최신 내용을 담고 있어요.

이런 책들을 읽어보시면 여려분들의 아키텍처를 더 좋게 바꿀 수 있는 힌트들을 발견할 수 있을꺼에요.

====

지금부터는 실제 적용했던 내용들을 잠깐 살펴볼까헤요.

제가 지금 있는 회사에서는 MSA를 적용하고 있으며, 클린 아키텍처를 적용하려고 노력중이에요.

====

MSA를 하다보면 프로젝트를 여러가지 만들어야 하는데, 그런 프로젝트를 쉽게 만들기 위한 template을 제공하고 있어요.

DDD, 클린 아키텍처가 기본적으로 적용되어있는 프로젝트 템플릿이에요. 그래서 개발자들이 큰 부담없이 DDD, Clean architecture를 적용할 수 있어요.

====

Clean Architecture, DDD는 단기간에 익히기는 어려운 방법일 수도 있어요.

특히 새로 오신 분들은 이런 내용을 전혀 모르는 경우도 많죠. 이런 점을 위하여 사내 워크샵을 진행하고 있어요.

같이 페어프로그래밍을 하면서 작은 프로젝트를 진행하며 DDD / CA를 같이 적용해볼 수 있어요.

이런 과정에서 설계를 하면서 할 수 있는 선택을 나열해서 살펴보고 그에 따른 영향도 같이 체험해보는거죠.

====

워크샵 뿐만 아니라 조금 더 기술적으로 도전적인 내용도 있기 마련이에요.

파이썬에서 풀어야 하는 문제들이나 전체 파이썬 프로젝트 퀄리티를 살펴보는 모임을 만들어서 활동하고있어요.

회사에서 파이썬을 좋아하는 분들끼리 모여서 주 1회 기술적인 내용도 공유하고, 어떻게 아키텍처를 발전시킬지에 대한 이야기도 하고 있어요.

====

하지만 이런 것들을 해도 문제점은 남아있어요.

프로젝트는 여전히 복잡한 경우도 있고, 모든 사람이 clean architecture에 관심이 있거나 잘 아는건 아니에요.

이전에 구성했던 아키텍처에 개선이 필요하지만 시간이 없어서 못하는 경우도 있구요.

특정 방법에 대하여 생각이 다른 경우도 있어요. 최근에는 project template에 어떤 내용까지 들어가는게 좋은지 이야기를 하기도 했어요.

====

사실 이번에 준비한 내용은 여기까지입니다.

지금까지 예시로 만들어둔 코드가 있으니 참고해주시면 좋을 것 같아요.

====

긴 발표 들어주셔서 감사합니다.
